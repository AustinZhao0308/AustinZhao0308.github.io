[{"title":"Hi there 👋  This is Austin Zhao!","url":"/2022/03/10/Welcome-to-my-blog/","content":"\n    \n     🧑‍💻 Quick Facts \n    \n         🛠️ A Chinese Independent Developer @ Hangzhou\n         📳 Intern of Stability Group @ Kuaishou\n         🎓 Computer Science and Technology Student @ ECNU\n         🎸 Lead Guitarist @ Cookiefei\n    \n    \n    \n    🛠️ Languages and Tools:\n    \n        &nbsp\n         &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n    \n    \n    \n    📫 How to reach me ...\n    \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  \n\n\n\n  \n  \n    \n    \n  \n\n\n\n\n\n\n🔭 I’m currently working on …\n"},{"title":"Hello World","url":"/2022/03/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"操作系统-线程实现的两种方式：用户空间与内核中","url":"/2022/05/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B8%AD/","content":"在用户空间中实现进程特点：整个线程包都会被放入用户空间之中，而内核对线程包一无所知。从内核的角度来说，他的管理方式就是普通的单线程进程。\n\n优点：\n    用户级线程包可以在不支持线程的操作系统上实现\n    这种方式的线程切换明显比内核的方式要快\n    允许每个进程自定义其自己的调度算法\n\n\n缺点\n    当线程进行I/O操作或页面故障引起阻塞的时候，如果调用阻塞系统调用则由于内核不知道有多线程存在，会阻塞整个进程而导致所有线程都被阻塞\n    一个单独的进程内部不存在时钟中断，所以不可能使用轮转调度的方式来调度线程\n\n\n\n    \n    \n\n\n在内核中实现进程特点：当某个线程希望创建一个新的线程或者撤销一个已有的线程的时候，它会进行一个系统调用，这个系统调用通过对线程的更新来完成线程创建或撤销工作\n\n优点：\n    所有能阻塞线程的调用都以系统调用的形式实现\n    如果某个线程引起了页面障碍，内核可以很方便的检查该进程是否有任何其他可运行的线程\n\n\n\n    \n    \n\n\n混合实现使用内核级线程，然后将用户级线程与某些或全部内核线路多路复用，如下图\n\n\n","categories":["操作系统"],"tags":["操作系统","学习笔记"]},{"title":"PyScript: 浏览器中的Python","url":"/2022/05/19/PyScript-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84Python/","content":"什么是PyScript？PyScript是一款由Anaconda的团队开发，的用于HTML中使用Python的系统。让我们可以在PyScript中调用JavaScript库，并使用Python进行Web开发。\n\n\n\n\nPyScript可以为我们带来什么？首先，最明显的就是我们现在可以使用Python来进行Web应用程序的构建了！\n并且在使用PyScript时我们并不需要担心部署，PyScript提供了“architectural shift beyond the cloud”。即一切转变都将在网络浏览器中发生。\n但是需要注意的是，虽然PyScript给我们提供了便利，但是它的运行速度也是我们需要考虑的问题。\n\n\n我们应该如何开始使用PyScript？ PyScript目前提供了两种使用的方式，分别是把官方提供的css于js文件下载或直接线上调用，并分别使用如下的语句将他们引用在你的HTML代码中：\n&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/pyscript.css&quot; /&gt;&lt;script defer src=&quot;path/to/pyscript.js&quot;&gt;&lt;/script&gt;\n\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot; /&gt;&lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt;\n\n不过我非常建议你使用第一种方式，因为经过实际测试第二种方式会消耗大量的时间(真的很慢！！！！！)\n在完成上述工作之后，我们就可以在HTML中加入我们的Python代码了！不过首先我们要学习的就是PyScript的三个主要组件：py-env, py-script, py-repl。\n\npy-env：这个组件用于引入在我们python代码中要使用的python包\n\npy-script：这个组件就是我们编写在网页中执行的python代码的地方\n\npy-repl：用于创建一个REPL(读取-评估-打印 循环)，用于评估用户输入的代码并显示结果。\n\n\npy-env在如下例子中，我们想将包numpy、pandas和scikit-learn加载到我们的环境中\n&lt;py-env&gt;    - numpy    - pandas    - scikit-learn&lt;/py-env&gt;\n\npy-script使用py-script组件时，我们可以选择引入写好的python文件或者直接在HTML代码中书写的方式 (类似于JavaScript)。\n&lt;py-script src=&quot;/python_file.py&quot;&gt;  &lt;/py-script&gt;\n\n&lt;py-script&gt; print(&quot;Hello PyScript!&quot;) &lt;/py-script&gt;\n\npy-repl这里我们引用anaconda官网上的例子，这个示例使用了DeckGL和REPL组件演示了具有NYC Taxi数据的Panel dashboard。如下图，我们可以在REPL中定义半径并选择dataframe的子集！\n\n示例源代码地址：https://github.com/pyscript/pyscript/blob/main/pyscriptjs/examples/panel_deckgl.html\n我们介绍了PyScript中的各个组件的作用，如果想要尝试更多也可以去到PyScript Github界面上来获取更多的示例代码。\n\n\nPyScript是如何开发的最后我们来介绍一下PyScript的技术栈：PyScript目前是基于Pyodide构建的，Pyodide是一个”CPython到WebAssembly&#x2F;Emscripten的端口”。PyScript目前支持在浏览器中使用Python，后续还将提供对其他语言的支持。\n\n\n参考\n[1] Anaconda Nucleus\n[2] GitHub - pyscript&#x2F;pyscript: Home Page: https://pyscript.net Examples: https://pyscript.net/examples\n[3] Pyodide &amp;#8212; Version 0.20.0\n\n","categories":["Web"],"tags":["Web","Python"]},{"title":"Android App 异常退出指标总结","url":"/2023/08/11/Android%20App%20%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA%E6%8C%87%E6%A0%87%E6%80%BB%E7%BB%93/","content":"\n👉 在入职大厂稳定性组之后遇到了很多不了解的 异常退出指标，于是准备写一篇总结的文章\n\nAndroid 异常退出指标\nJava Crash  “Java Crash” 是指在Java编程语言中，应用程序在运行过程中由于错误或异常而导致程序终止或崩溃的情况。Java程序的崩溃可能会导致程序无法正常运行，甚至可能引起系统的不稳定。\n  Java Crash 可能由各种原因引起，例如：\n\n空指针引用（NullPointerException）： 当尝试访问一个空对象引用（null引用）上的方法或属性时，会抛出空指针异常，导致程序崩溃。\n\n数组越界（ArrayIndexOutOfBoundsException）： 当尝试访问数组中不存在的索引位置时，会抛出数组越界异常，导致程序崩溃。\n\n内存溢出（OutOfMemoryError）： 当程序尝试分配更多内存资源而导致内存不足时，会抛出内存溢出异常，导致程序崩溃。\n\n未捕获的异常： 如果程序中某个异常没有被适当地捕获和处理，它可能会传播到程序的顶层，并导致程序崩溃。\n\n栈溢出（StackOverflowError）： 当递归函数调用层次太深，导致函数调用栈溢出时，会抛出栈溢出异常，导致程序崩溃。\n\n虚拟机错误： 有时候虚拟机自身也可能遇到问题，例如无法启动、配置错误等，导致程序崩溃。\n\n\n  为了避免 Java Crash，开发人员应该编写健壮的代码，正确地处理各种异常情况，避免空指针引用和数组越界等问题，进行适当的内存管理，避免递归调用过深，以及监控和调试程序以解决未知问题。使用适当的异常处理机制可以帮助程序更容易地从错误中恢复，而不是直接崩溃。\n\n  \n\nNative Crash  Android Native Crash（本地崩溃）是指在Android应用程序中，由于本地代码（通常是C或C++代码）发生错误或异常而导致应用程序崩溃的情况。这种崩溃通常涉及应用程序的底层代码，如使用NDK编写的本地库。\n  本地崩溃的可能原因有很多，以下是一些常见的原因：\n\n空指针引用（Null Pointer Dereference）： 本地代码中使用了空指针，导致访问无效内存地址，触发崩溃。\n\n内存访问越界（Buffer Overflow）： 本地代码中数组或缓冲区的访问超过了其范围，导致读写无效内存，引发崩溃。\n\n无效的内存释放（Invalid Memory Deallocation）： 释放了已经被释放或不属于本地库管理的内存块，可能导致后续访问崩溃。\n\n多线程同步问题（Multithreading Issues）： 多个线程并发执行本地代码，缺乏正确的同步机制可能导致数据竞争和崩溃。\n\n本地代码逻辑错误（Logic Errors in Native Code）： 本地代码中的逻辑错误可能导致错误的计算或控制流程，从而引发崩溃。\n\n调用标准C库函数错误（Incorrect Use of Standard C Library Functions）： 不正确地使用C标准库函数，如内存分配和字符串操作，可能引发崩溃。\n\n硬件相关问题（Hardware-related Issues）： 涉及硬件资源的问题，如访问非法硬件寄存器，可能导致崩溃。\n\n调用Java代码错误（Incorrect Invocation of Java Code）： 从本地代码中调用Java方法时的错误使用，可能导致崩溃。\n\nNDK版本兼容性问题（NDK Version Compatibility Issues）： 使用不兼容的NDK版本或库可能导致崩溃。\n\n其他库的错误（Errors in Other Libraries）： 本地代码使用的外部库可能存在错误，影响了应用程序的稳定性。\n\n\n  为了解决本地崩溃问题，开发人员可以采取以下措施：\n\n仔细检查本地代码，避免使用空指针和无效的内存访问。\n使用适当的同步机制来处理多线程问题。正确释放内存，并避免出现内存泄漏。\n使用C和C++编码标准，避免常见的编程错误。\n使用调试工具和日志记录来追踪和诊断本地崩溃。\n在NDK的应用中，确保正确选择和配置NDK版本，以及依赖库的版本。\n在处理本地崩溃问题时，了解常见原因和采取适当的调试和优化措施是非常重要的。\n\n\n  \n\n ANR (Application Not Response)   ANR（Application Not Responding）是指Android应用程序在一段时间内未能响应用户输入或操作的情况。当应用程序变得无法响应时，Android系统会认为应用程序出现了问题，并弹出一个ANR对话框，通知用户应用程序未响应。\n  ANR可能由多种原因引起，以下是一些常见的原因：\n\n主线程阻塞： 主线程是负责处理用户界面的线程。如果在主线程上执行了耗时操作，比如网络请求、数据库查询或复杂的计算，会导致主线程阻塞，从而使应用程序无法响应用户操作。\n\n长时间的I&#x2F;O操作： 当应用程序在主线程上执行长时间的I&#x2F;O操作，如读写文件、数据库操作等，主线程会被阻塞，导致应用程序无法响应。\n\n死锁（Deadlock）： 死锁是指多个线程互相等待对方释放锁的状态。如果发生死锁，线程无法继续执行，导致应用程序无法响应。\n\nUI线程上的耗时计算： 如果在UI线程上执行复杂的计算，会导致UI线程阻塞，影响应用程序的响应性。\n\n未捕获的异常： 如果在应用程序中某处发生未捕获的异常，会导致应用程序崩溃或阻塞，从而引发ANR。\n\n广播接收器阻塞： 如果在广播接收器中执行耗时操作，可能会导致主线程阻塞，从而引发ANR。\n\n前台服务超时： 前台服务在一定时间内未完成任务可能引发ANR。\n\n系统资源耗尽： 如果应用程序占用了过多的内存、CPU等系统资源，可能导致系统资源不足，从而导致ANR。\n\n\n  为了避免ANR问题，开发人员可以采取以下措施：\n\n在主线程上避免执行耗时操作，将耗时操作放在后台线程中进行。\n使用异步任务、线程池或Handler等机制来处理后台操作。\n使用适当的同步机制，避免发生死锁。\n使用异常处理机制捕获并处理异常，避免应用程序崩溃或阻塞。\n避免在广播接收器中执行耗时操作，尽量保持接收器的执行时间短暂。\n对于前台服务，确保在规定的时间内完成任务。\n对应用程序的资源使用进行优化，避免占用过多的系统资源。\n通过合理的设计和优化，可以有效减少ANR问题的出现，提升应用程序的响应性和用户体验。\n\n\n  \n\n LMK (Low Memory Killer)  LMK（Low Memory Killer）是Android操作系统中的一个重要组件，用于在系统内存不足时终止或杀死一些应用程序进程，以释放内存资源，从而防止系统崩溃或变得不稳定。LMK是Android系统的一种内存管理机制，旨在优化系统的性能和稳定性。\n  LMK的主要原因在于系统内存有限，当多个应用程序同时运行并占用大量内存时，系统可能会出现内存不足的情况。这可能导致系统性能下降、应用程序响应变慢甚至崩溃。为了应对这种情况，LMK会监测系统内存的使用情况，并在内存资源不足时采取措施。\n  LMK的工作原理如下：\n\n内存分级： Android将系统内存划分为不同的级别，每个级别有不同的优先级。这些级别从低到高分为多个”类别”（category）。\n\n内存压力检测： Android的内存管理系统会定期检测系统内存的压力情况。如果系统内存紧张，内存压力会增加。\n\n内存回收： 当内存压力升高时，LMK会开始回收内存资源。它会优先终止优先级较低的应用程序进程，释放它们占用的内存。\n\n杀进程： 如果内存压力继续增加，LMK可能会终止更多的应用程序进程，以释放更多的内存资源。这可能会影响到用户在后台运行的应用程序。\n\n\n  需要注意的是，LMK的设计是为了维护系统的整体稳定性，而不是优先考虑单个应用程序的需求。这意味着，尽管LMK可以确保系统不会因为内存不足而崩溃，但在内存紧张的情况下，一些应用程序可能会被终止以释放资源。\n  开发人员可以通过一些方法来减少应用程序被LMK终止的可能性，例如：\n\n使用适当的内存管理策略，避免内存泄漏和过度使用内存。\n使用合理的后台任务处理机制，避免占用过多的系统资源。\n避免在后台运行过多的进程或服务，以释放更多的内存资源给前台应用程序。\n使用适当的线程和进程管理，避免长时间运行的任务占用过多的内存。\n通过优化应用程序的内存使用和管理，开发人员可以减少LMK的影响，并提供更好的用户体验。\n\n\n  \n\nSystem Kill  “System Kill” 是指 Android 系统在内存紧张的情况下，为了保证系统的稳定性和可用性，选择终止或杀死某些系统进程或服务的行为。这是一种内存管理策略，旨在防止系统耗尽内存资源而导致系统崩溃或不稳定。\n  System Kill 的原因主要是出于系统内存不足的情况。当系统内存紧张，无法满足运行中应用程序和系统进程的内存需求时，系统会采取一些措施来释放内存资源，以防止系统的整体性能下降。System Kill 通常会优先终止一些优先级较低的系统进程，从而为重要的系统进程和前台应用程序腾出更多内存。\n  System Kill 可能影响到一些系统功能和服务，如后台应用程序、系统服务以及一些不常用的进程。然而，系统会优先保留对用户界面、系统核心服务和正在交互的前台应用程序的支持，以确保用户体验和系统的稳定性。\n  在 System Kill 的情况下，一些可能受影响的因素和原因包括：\n\n后台应用程序： 优先终止后台运行的应用程序，释放它们占用的内存资源。\n系统服务： 一些系统服务可能会被终止，导致某些功能受到影响。系统会优先保留核心的系统服务。\n不常用的进程： 一些不常用的进程可能会被终止，以腾出内存。\n进程优先级： 系统会根据进程的优先级来决定终止的顺序。优先级较低的进程可能更容易被终止。  \n\n  需要注意的是，System Kill 是为了确保系统稳定性而采取的一种内存管理策略。在大多数情况下，用户可能不会察觉到 System Kill 的影响，因为系统会尽量保持核心功能和前台应用的正常运行。开发人员应该注意合理管理应用程序的内存使用，以减少被 System Kill 的可能性，并提供更好的用户体验。\n\n  \n\nSIGNALED  在 Android 应用程序中，”Signaled异常退出” 是指应用程序在某些特定情况下收到操作系统信号（signal）而导致异常退出的情况。这些信号可能由操作系统或其他进程触发，通常表示了应用程序遇到了一些严重的问题或错误。这种异常退出可以导致应用程序崩溃、强制关闭或异常终止。\n  在 Android 中，一些常见的导致 Signaled 异常退出的原因包括：\n\nSIGSEGV（Segmentation Violation）： 这是一种段错误信号，表示应用程序试图访问无效的内存地址，通常由于内存访问越界或无效的指针引用导致。\n\nSIGABRT（Abort）： 这是一种中止信号，通常是由于应用程序内部检测到了无法继续运行的错误，比如断言失败或其他逻辑错误。\n\nSIGILL（Illegal Instruction： 这是一种非法指令信号，表示应用程序试图执行不合法的机器指令。\n\nSIGBUS（Bus Error）： 这是一种总线错误信号，表示应用程序试图访问无效的内存地址，类似于 SIGSEGV。\n\nSIGFPE（Floating Point Exception）： 这是一种浮点异常信号，表示应用程序执行了非法的浮点操作，如除以零或溢出。\n\nSIGTERM（Termination）： 这是一种终止信号，通常用于表示应用程序被请求终止，可以由用户、系统或其他进程发起。\n\n其他信号： 还有一些其他的信号，如 SIGHUP、SIGINT、SIGKILL 等，每个信号都有不同的含义和影响。\n\n\n  这些信号可能是由应用程序内部错误、系统问题、库调用失败等多种原因引发的。在 Android 中，一旦应用程序收到了这些信号，通常会触发异常处理机制，有时可能会导致应用程序崩溃或被系统终止。对于某些信号，应用程序可能有机会进行一些清理操作，但有些信号是无法捕获或忽略的，如 SIGKILL。\n  为了减少 Signaled 异常退出的发生，开发人员可以：\n\n编写健壮的代码，避免内存越界、非法指令和浮点异常等问题。\n使用适当的异常处理机制来捕获和处理可能出现的异常情况。\n进行严格的代码测试和质量控制，以发现并修复潜在的问题。\n避免在应用程序中使用无效的指针引用或未经初始化的变量。\n使用合适的错误处理和日志记录，以便能够追踪和调试异常情况。\n\n\n  \n\n EXIT SELF   在 Android 应用程序开发中，”EXIT_SELF” 是指应用程序内部通过编程方式自行选择退出的行为。这意味着应用程序在特定条件下，主动调用代码来触发自身的退出操作，而不是被系统强制退出或由其他外部因素引起的。\n  EXIT_SELF 的原因通常是由于特定的应用逻辑、用户需求或资源管理需要。以下是一些常见的情况和原因，导致 Android 应用程序可能选择进行 EXIT_SELF 操作：\n\n用户主动退出： 应用程序内部提供了退出按钮或选项，让用户主动退出应用，通常通过调用 finish() 方法来实现。\n\n完成任务后退出： 当应用程序完成某个任务、流程或操作后，根据业务需求，可能选择退出以提供一种流程的结束感。\n\n用户状态失效： 在需要用户登录状态的应用中，如果用户登录状态失效（例如，登录过期），应用程序可能会选择退出，以确保用户数据的安全性。\n\n用户权限变更： 如果用户权限发生变化，导致应用程序无法正常运行或提供所需的功能，可能会选择退出。\n\n资源管理： 在资源紧张的情况下，应用程序可能会自行退出以释放资源，例如网络连接不可用、硬件支持不足等。\n\n应用设置： 用户可能在应用设置中设置了特定的退出条件，当这些条件满足时，应用程序可能会执行退出操作。\n\n特殊场景处理： 在某些情况下，应用程序可能会根据特殊的场景需求，如特定时间、地理位置等，选择退出。\n\n测试和调试： 在测试和调试阶段，开发人员可能会在特定情况下触发退出操作以验证应用程序的行为。\n\n\n  在实现 EXIT_SELF 操作时，开发人员应该确保在退出前进行必要的资源释放、数据保存、清理等操作，以确保退出过程的平稳和用户体验。同时，也需要考虑应用退出后的行为，如是否显示退出提示、保存用户数据等。\n  总之，EXIT_SELF 是指应用程序自己选择退出，这在某些场景下可以用于提供更好的用户体验或满足业务需求。\n\n\n以上就是总结的一些Android中的异常退出指标，如有错误欢迎各位大佬指正。\n","categories":["Android"],"tags":["Android","稳定性"]},{"title":"各类ASan工具变种总结","url":"/2023/08/21/%E5%90%84%E7%B1%BBASan%E5%B7%A5%E5%85%B7%E5%8F%98%E7%A7%8D%E6%80%BB%E7%BB%93/","content":"\n👉 接手了一个GWP-ASan相关的开发需求，但对ASan不是很了解，在网上查找ASan工具的相关知识后，发现并没有很清楚而统一的对多种ASan工具的变种的介绍，所以决定自己写一篇。如果有不对的地方欢迎大家指正 🥹\n\n各类ASan工具变种总结1. ASan简介及面对的问题：在使用高级编程语言 (这里主要指Java、Kotlin) 开发的时候，因为虚拟机的存在，所以我们往往不需要考虑内存访问相关的错误。但是一旦使用了一些底层编程语言 (比如C、C++等) ，来进行与操作系统或硬件直接的交互的底层的Native编程时，则可能会遇到更多的与内存访问相关的错误问题 (因为此时开发者可能需要自行负责内存的分配、释放、访问等，而不是由高级语言进行自动内存管理) 。这些错误问题主要包含了：\n\n内存泄漏：不正确的内存分配和释放可能导致内存泄漏，使应用的内存占用不断增加，最终导致应用崩溃或性能下降。\n野指针和悬空指针：在C&#x2F;C++中，开发者需要手动管理指针，而不当地使用野指针或悬空指针可能导致未定义的行为、崩溃或数据损坏。\n缓冲区溢出：对于数组或缓冲区的访问不当可能导致缓冲区溢出，从而覆盖其他内存区域的数据，引发各种问题，包括安全漏洞。\n并发和线程安全性：底层编程可能涉及多线程编程，需要处理并发和线程安全性问题，如竞态条件、死锁等。\n性能优化和调试：底层编程的性能和调试要求可能更高，需要更深入的优化技巧和工具。\n\n这些错误会引发很多应用使用上的问题甚至是安全问题，而且往往很难与排查，所以产生了很多处理此类问题的工具，ASan就是其中的一种。本篇博客中我们主要介绍ASan及其两种变体HWASan以及GWP-ASan。\n2. ASan的原理解析ASan的全名叫做 Address Sanitizer。我们先来笼统的了解一下它的基本工作过程：\n\n编译时插桩：在代码编译阶段，ASan使用编译器插桩技术将原始代码进行修改，以在运行时进行内存访问检查。这意味着生成的可执行文件会包含额外的代码，用于记录和检测内存访问操作。\n内存布局重排：ASan会重新安排程序的内存布局，以便有效地检测内存访问错误。它在每个分配的内存块之前和之后插入“红区”（Redzone） - 一段附加内存，用于检测缓冲区溢出。如果程序尝试访问红区，ASan会立即报告错误。\n元数据存储：ASan会维护元数据（metadata）来跟踪分配的内存块信息。这些元数据存储在与内存块一起分配的内存块中，并记录有关块的大小、状态等信息。这些信息有助于检测释放后的内存访问错误。\n运行时检查：当程序运行时，插入的ASan代码会在每个内存访问操作（读取或写入）之前和之后执行。它会检查目标内存是否位于合法的范围内，以及是否与其他内存块重叠。如果发现内存访问错误，ASan会触发报告，并指出错误发生的位置、类型和详细信息。\n报告生成：当ASan检测到内存错误时，它会生成一个详细的报告，包括错误类型、错误位置、堆栈跟踪等信息。这些报告可以帮助开发者定位和修复问题。\n\n总结的说，ASan主要由两部分工具组成：插桩模块以及一个运行时库:\n插桩模块主要对所有的内存访问 (memory accss)都去检查该内存所对应的 shadow memory的状态。这是静态插桩，需要重新编译。然后为栈上对象和全局对象创建前后的保护区，为检测溢出来做准备。\n而运行时库会替换默认路径的malloc&#x2F;free等函数。为所有堆对象创建前后的保护区，将free掉的堆区域隔离一段时间，避免起马上被分配使用。并且运行时库也会对错误情况进行输出(包括堆栈信息)。\n3. Asan的缺陷自从2011年诞生以来，ASAN已经成功地参与了众多大型项目，譬如Chrome和Android。虽然它的表现很突出，但仍然有些地方不尽如人意，重点表现在以下几点：\n\nASAN的运行是需要消耗memory和CPU资源的，此外它也会增加代码大小。它的性能相比于之前的工具确实有了质的提升，但仍然无法适用于某些压力测试场景，尤其是需要全局打开的时候。这一点在Android上尤为明显，每当我们想要全局打开ASAN调试某些奇葩问题时，系统总会因为负载过重而跑不起来。\nASAN对于UseAfterFree的检测依赖于隔离区，而隔离时间是非永久的。也就意味着已经free的区域过一段时间后又会重新被分配给其他人。当它被重新分配给其他人后，原先的持有者再次访问此块区域将不会报错。因为这一块区域的shadow memory不再是0xfd。所以这算是ASAN漏检的一种情况。\nASAN对于overflow的检测依赖于安全区，而安全区总归是有大小的。它可能是64bytes，128bytes或者其他什么值，但不管怎么样终归是有限的。如果某次踩踏跨过了安全区，踩踏到另一片可寻址的内存区域，ASAN同样不会报错。这是ASAN的另一种漏检。\n\n4. HWASan (需要64位硬件)HWASAN是ASAN工具的“升级版”，它基本上解决了上面所说的ASAN的3个问题。但是它需要64位硬件的支持，也就是说在32位的机器上该工具无法运行。\nAArch64是64位的架构，指的是寄存器的宽度是64位，但并不表示内存的寻址范围是2^64。真实的寻址范围和处理器内部的总线宽度有关，实际上ARMv8寻址只用到了低48位。也就是说，一个64bit的指针值，其中真正用于寻址的只有低48位。那么剩下的高16位干什么用呢？答案是随意发挥。AArch64拥有地址标记(Address tagging, or top-byte-ignore)的特性，它表示允许软件使用64bit指针值的高8位开发特定功能。\nHWASAN用这8bit来存储一块内存区域的标签(tag)。接下来我们以堆内存示例，展示这8bit到底如何起作用。\n堆内存通过malloc分配出来，HWASAN在它返回地址时会更改该有效地址的高8位。更改的值是一个随机生成的单字节值，譬如0xaf。此外，该分配出来的内存对应的shadow memory值也设为0xaf。需要注意的是，HWASAN中normal memory和shadow memory的映射关系是16➡1，而ASAN中二者的映射关系是8➡1。\n相对于ASan，HWASan有以下的升级与优势：\n\n性能提升：ASan在运行时会插入大量的检查代码，导致程序的性能受到影响。HWASan利用了硬件的辅助，例如硬件内存分页机制，从而在运行时检测内存错误，减少了插桩代码的数量，从而提高了程序的性能。\n\n减少内存占用：ASan需要为每个分配的内存块添加额外的红区（redzone）以及元数据，从而增加了内存占用。HWASan在硬件级别实现了内存保护，不需要额外的红区和元数据，因此可以减少内存占用。\n\n硬件支持：HWASan利用了现代处理器的硬件特性，如硬件内存保护单元（MMU）等，从而在硬件层面提供内存错误检测，使得检测过程更高效。\n\n适用于大型程序：由于ASan插桩代码较多，对于大型程序可能产生较大的性能开销。HWASan通过硬件支持能够更好地适应大型程序，减少了性能开销。\n\n兼容性：HWASan可以与现有的ASan代码一起使用，开发者可以根据需要在不同的场景中选择使用ASan或HWASan。\n\n\n5. GWP-ASan (GWP-ASan Will Provide Allocation SANity)与 HWASan 或 Malloc 调试 不同，GWP-ASan 不需要源代码或重新编译（即使用预构建文件），并且同时适用于 32 位和 64 位进程（但 32 位崩溃的调试信息较少）。\na. GWP-ASan与ASan的区别：GWP-ASan（Google’s Weak-Point AddressSanitizer）是AddressSanitizer（ASan）的一个优化版本，主要针对内存错误的“弱点”进行检测，以减少对性能的影响。以下是GWP-ASan相比于传统ASan的优化之处：\n\n性能优化：传统的ASan在检测内存错误方面非常强大，但在某些情况下会产生较大的性能开销。GWP-ASan则专注于内存错误的“弱点”，通过使用监视指针来管理内存，减少了不必要的检查，从而降低了性能开销。\n\n精简的内存保护：GWP-ASan使用了一种更轻量级的内存保护方法，称为“监视指针”。这些指针位于内存块的开头和结尾，用于检测内存溢出、内存释放后的使用等问题。相比于传统ASan需要在每个分配的内存块中插入大量的元数据，GWP-ASan的内存保护方法更为精简。\n\n更适用于生产环境：传统的ASan通常用于开发和测试阶段，因为它可能会对性能产生较大的影响。而GWP-ASan专注于在生产环境中提供轻量级的内存错误检测，它的目标是尽可能减少性能开销，从而使得在实际生产环境中使用更为可行。\n\n定位“弱点”错误：GWP-ASan主要关注于检测内存错误的“弱点”，如使用已释放的内存、使用悬空指针等。传统ASan的目标更广泛，可以发现更多类型的内存错误。\n\n\n需要注意的是，GWP-ASan并不是传统ASan的替代品，而是一种针对特定场景和目标的优化版本。如果开发者关注在生产环境中的轻量级内存错误检测，以及减少性能开销，那么GWP-ASan可能是一个更好的选择。然而，对于需要广泛和深入的内存错误检测的情况，传统ASan可能更为适合。\n\nb. GWP-ASan与HWASan的区别GWP-ASan（Google’s Weak-Point AddressSanitizer）和HWASan（Hardware-Assisted AddressSanitizer）都是内存错误检测技术的变种，但它们在实现和目标方面存在一些区别。以下是GWP-ASan相对于HWASan的区别：\n\n实现原理：\n\nGWP-ASan：GWP-ASan是基于软件的内存错误检测技术，使用特殊的监视指针来管理内存块，并关注于内存错误的“弱点”。\nHWASan：HWASan是基于硬件的内存错误检测技术，利用硬件支持来提高内存错误检测的性能和效率。\n\n\n目标和重点：\n\nGWP-ASan：GWP-ASan主要关注于内存错误的“弱点”，如使用已释放的内存、使用悬空指针等。它旨在在生产环境中提供轻量级的内存错误检测，以减少对性能的影响。\nHWASan：HWASan的目标是提高内存错误检测的性能和效率，它利用硬件辅助来加速内存错误的检测过程，适用于需要更高性能的场景。\n\n\n性能开销：\n\nGWP-ASan：相比传统的ASan，GWP-ASan试图降低内存错误检测的性能开销，专注于生产环境中的轻量级检测。\nHWASan：HWASan通过硬件支持提供内存错误检测，可以更有效地减少运行时的性能开销。\n\n\n硬件支持：\n\nGWP-ASan：GWP-ASan不依赖于特定的硬件支持，它是基于软件的解决方案。\nHWASan：HWASan利用了现代处理器的硬件特性，如硬件内存分页机制，以提高内存错误检测的效率。\n\n\n\n选择使用GWP-ASan还是HWASan取决于具体的应用场景和需求。如果你关注的是在生产环境中提供轻量级的内存错误检测，并且希望减少性能开销，那么GWP-ASan可能更适合。如果你需要更高性能的内存错误检测，并且你的硬件支持HWASan的特性，那么HWASan可能是更好的选择。\n6.总结本文全面介绍了多种ASan工具变种，用于解决底层编程语言中的内存错误问题。ASan作为主要工具，通过编译时插桩和运行时检查，有效地识别内存泄漏、野指针、缓冲区溢出等问题。然而，ASan也存在一些性能和漏检方面的限制。HWASan在64位硬件上实现了硬件辅助，提升了性能和内存利用率，成为ASan的升级版。而GWP-ASan专注于内存错误的“弱点”，提供了轻量级的生产环境内存错误检测。这些工具各有优势，开发者可根据需求选择最适合的工具，以提升应用程序的质量和性能。\n参考文献\nhttps://cloud.tencent.com/developer/article/1657154\nhttps://akinian.fandom.com/zh/wiki/%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF\nhttps://akinian.fandom.com/zh/wiki/%E5%BD%B1%E5%AD%90%E5%86%85%E5%AD%98_(Shadow_Memory)\n\n","categories":["Android"],"tags":["Android","稳定性"]}]