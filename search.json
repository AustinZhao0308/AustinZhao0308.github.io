[{"title":"Hi there 👋  This is Austin Zhao!","url":"/2022/03/10/Welcome-to-my-blog/","content":"\n    \n     🧑‍💻 Quick Facts \n    \n         🛠️ A Chinese Independent Developer @ Hangzhou\n         📳 Intern of Stability Group @ Kuaishou\n         🎓 Computer Science and Technology Student @ ECNU\n         🎸 Lead Guitarist @ Cookiefei\n    \n    \n    \n    🛠️ Languages and Tools:\n    \n        &nbsp\n         &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n        &nbsp\n    \n    \n    \n    📫 How to reach me ...\n    \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  &nbsp;&nbsp;\n  \n  \n    \n      \n    \n  \n\n\n\n  \n  \n    \n    \n  \n\n\n\n\n\n\n🔭 I’m currently working on …\n"},{"title":"Hello World","url":"/2022/03/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"操作系统-线程实现的两种方式：用户空间与内核中","url":"/2022/05/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E4%B8%AD/","content":"在用户空间中实现进程特点：整个线程包都会被放入用户空间之中，而内核对线程包一无所知。从内核的角度来说，他的管理方式就是普通的单线程进程。\n\n优点：\n    用户级线程包可以在不支持线程的操作系统上实现\n    这种方式的线程切换明显比内核的方式要快\n    允许每个进程自定义其自己的调度算法\n\n\n缺点\n    当线程进行I/O操作或页面故障引起阻塞的时候，如果调用阻塞系统调用则由于内核不知道有多线程存在，会阻塞整个进程而导致所有线程都被阻塞\n    一个单独的进程内部不存在时钟中断，所以不可能使用轮转调度的方式来调度线程\n\n\n\n    \n    \n\n\n在内核中实现进程特点：当某个线程希望创建一个新的线程或者撤销一个已有的线程的时候，它会进行一个系统调用，这个系统调用通过对线程的更新来完成线程创建或撤销工作\n\n优点：\n    所有能阻塞线程的调用都以系统调用的形式实现\n    如果某个线程引起了页面障碍，内核可以很方便的检查该进程是否有任何其他可运行的线程\n\n\n\n    \n    \n\n\n混合实现使用内核级线程，然后将用户级线程与某些或全部内核线路多路复用，如下图\n\n\n","categories":["操作系统"],"tags":["操作系统","学习笔记"]},{"title":"PyScript: 浏览器中的Python","url":"/2022/05/19/PyScript-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84Python/","content":"什么是PyScript？PyScript是一款由Anaconda的团队开发，的用于HTML中使用Python的系统。让我们可以在PyScript中调用JavaScript库，并使用Python进行Web开发。\n\n\n\n\nPyScript可以为我们带来什么？首先，最明显的就是我们现在可以使用Python来进行Web应用程序的构建了！\n并且在使用PyScript时我们并不需要担心部署，PyScript提供了“architectural shift beyond the cloud”。即一切转变都将在网络浏览器中发生。\n但是需要注意的是，虽然PyScript给我们提供了便利，但是它的运行速度也是我们需要考虑的问题。\n\n\n我们应该如何开始使用PyScript？ PyScript目前提供了两种使用的方式，分别是把官方提供的css于js文件下载或直接线上调用，并分别使用如下的语句将他们引用在你的HTML代码中：\n&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/pyscript.css&quot; /&gt;&lt;script defer src=&quot;path/to/pyscript.js&quot;&gt;&lt;/script&gt;\n\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot; /&gt;&lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt;\n\n不过我非常建议你使用第一种方式，因为经过实际测试第二种方式会消耗大量的时间(真的很慢！！！！！)\n在完成上述工作之后，我们就可以在HTML中加入我们的Python代码了！不过首先我们要学习的就是PyScript的三个主要组件：py-env, py-script, py-repl。\n\npy-env：这个组件用于引入在我们python代码中要使用的python包\n\npy-script：这个组件就是我们编写在网页中执行的python代码的地方\n\npy-repl：用于创建一个REPL(读取-评估-打印 循环)，用于评估用户输入的代码并显示结果。\n\n\npy-env在如下例子中，我们想将包numpy、pandas和scikit-learn加载到我们的环境中\n&lt;py-env&gt;    - numpy    - pandas    - scikit-learn&lt;/py-env&gt;\n\npy-script使用py-script组件时，我们可以选择引入写好的python文件或者直接在HTML代码中书写的方式 (类似于JavaScript)。\n&lt;py-script src=&quot;/python_file.py&quot;&gt;  &lt;/py-script&gt;\n\n&lt;py-script&gt; print(&quot;Hello PyScript!&quot;) &lt;/py-script&gt;\n\npy-repl这里我们引用anaconda官网上的例子，这个示例使用了DeckGL和REPL组件演示了具有NYC Taxi数据的Panel dashboard。如下图，我们可以在REPL中定义半径并选择dataframe的子集！\n\n示例源代码地址：https://github.com/pyscript/pyscript/blob/main/pyscriptjs/examples/panel_deckgl.html\n我们介绍了PyScript中的各个组件的作用，如果想要尝试更多也可以去到PyScript Github界面上来获取更多的示例代码。\n\n\nPyScript是如何开发的最后我们来介绍一下PyScript的技术栈：PyScript目前是基于Pyodide构建的，Pyodide是一个”CPython到WebAssembly&#x2F;Emscripten的端口”。PyScript目前支持在浏览器中使用Python，后续还将提供对其他语言的支持。\n\n\n参考\n[1] Anaconda Nucleus\n[2] GitHub - pyscript&#x2F;pyscript: Home Page: https://pyscript.net Examples: https://pyscript.net/examples\n[3] Pyodide &amp;#8212; Version 0.20.0\n\n","categories":["Web"],"tags":["Web","Python"]},{"title":"Android App 异常退出指标总结","url":"/2023/08/11/Android%20App%20%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA%E6%8C%87%E6%A0%87%E6%80%BB%E7%BB%93/","content":"\n👉 在入职大厂稳定性组之后遇到了很多不了解的 异常退出指标，于是准备写一篇总结的文章\n\nAndroid 异常退出指标\nJava Crash  “Java Crash” 是指在Java编程语言中，应用程序在运行过程中由于错误或异常而导致程序终止或崩溃的情况。Java程序的崩溃可能会导致程序无法正常运行，甚至可能引起系统的不稳定。\n  Java Crash 可能由各种原因引起，例如：\n\n空指针引用（NullPointerException）： 当尝试访问一个空对象引用（null引用）上的方法或属性时，会抛出空指针异常，导致程序崩溃。\n\n数组越界（ArrayIndexOutOfBoundsException）： 当尝试访问数组中不存在的索引位置时，会抛出数组越界异常，导致程序崩溃。\n\n内存溢出（OutOfMemoryError）： 当程序尝试分配更多内存资源而导致内存不足时，会抛出内存溢出异常，导致程序崩溃。\n\n未捕获的异常： 如果程序中某个异常没有被适当地捕获和处理，它可能会传播到程序的顶层，并导致程序崩溃。\n\n栈溢出（StackOverflowError）： 当递归函数调用层次太深，导致函数调用栈溢出时，会抛出栈溢出异常，导致程序崩溃。\n\n虚拟机错误： 有时候虚拟机自身也可能遇到问题，例如无法启动、配置错误等，导致程序崩溃。\n\n\n  为了避免 Java Crash，开发人员应该编写健壮的代码，正确地处理各种异常情况，避免空指针引用和数组越界等问题，进行适当的内存管理，避免递归调用过深，以及监控和调试程序以解决未知问题。使用适当的异常处理机制可以帮助程序更容易地从错误中恢复，而不是直接崩溃。\n\n  \n\nNative Crash  Android Native Crash（本地崩溃）是指在Android应用程序中，由于本地代码（通常是C或C++代码）发生错误或异常而导致应用程序崩溃的情况。这种崩溃通常涉及应用程序的底层代码，如使用NDK编写的本地库。\n  本地崩溃的可能原因有很多，以下是一些常见的原因：\n\n空指针引用（Null Pointer Dereference）： 本地代码中使用了空指针，导致访问无效内存地址，触发崩溃。\n\n内存访问越界（Buffer Overflow）： 本地代码中数组或缓冲区的访问超过了其范围，导致读写无效内存，引发崩溃。\n\n无效的内存释放（Invalid Memory Deallocation）： 释放了已经被释放或不属于本地库管理的内存块，可能导致后续访问崩溃。\n\n多线程同步问题（Multithreading Issues）： 多个线程并发执行本地代码，缺乏正确的同步机制可能导致数据竞争和崩溃。\n\n本地代码逻辑错误（Logic Errors in Native Code）： 本地代码中的逻辑错误可能导致错误的计算或控制流程，从而引发崩溃。\n\n调用标准C库函数错误（Incorrect Use of Standard C Library Functions）： 不正确地使用C标准库函数，如内存分配和字符串操作，可能引发崩溃。\n\n硬件相关问题（Hardware-related Issues）： 涉及硬件资源的问题，如访问非法硬件寄存器，可能导致崩溃。\n\n调用Java代码错误（Incorrect Invocation of Java Code）： 从本地代码中调用Java方法时的错误使用，可能导致崩溃。\n\nNDK版本兼容性问题（NDK Version Compatibility Issues）： 使用不兼容的NDK版本或库可能导致崩溃。\n\n其他库的错误（Errors in Other Libraries）： 本地代码使用的外部库可能存在错误，影响了应用程序的稳定性。\n\n\n  为了解决本地崩溃问题，开发人员可以采取以下措施：\n\n仔细检查本地代码，避免使用空指针和无效的内存访问。\n使用适当的同步机制来处理多线程问题。正确释放内存，并避免出现内存泄漏。\n使用C和C++编码标准，避免常见的编程错误。\n使用调试工具和日志记录来追踪和诊断本地崩溃。\n在NDK的应用中，确保正确选择和配置NDK版本，以及依赖库的版本。\n在处理本地崩溃问题时，了解常见原因和采取适当的调试和优化措施是非常重要的。\n\n\n  \n\n ANR (Application Not Response)   ANR（Application Not Responding）是指Android应用程序在一段时间内未能响应用户输入或操作的情况。当应用程序变得无法响应时，Android系统会认为应用程序出现了问题，并弹出一个ANR对话框，通知用户应用程序未响应。\n  ANR可能由多种原因引起，以下是一些常见的原因：\n\n主线程阻塞： 主线程是负责处理用户界面的线程。如果在主线程上执行了耗时操作，比如网络请求、数据库查询或复杂的计算，会导致主线程阻塞，从而使应用程序无法响应用户操作。\n\n长时间的I&#x2F;O操作： 当应用程序在主线程上执行长时间的I&#x2F;O操作，如读写文件、数据库操作等，主线程会被阻塞，导致应用程序无法响应。\n\n死锁（Deadlock）： 死锁是指多个线程互相等待对方释放锁的状态。如果发生死锁，线程无法继续执行，导致应用程序无法响应。\n\nUI线程上的耗时计算： 如果在UI线程上执行复杂的计算，会导致UI线程阻塞，影响应用程序的响应性。\n\n未捕获的异常： 如果在应用程序中某处发生未捕获的异常，会导致应用程序崩溃或阻塞，从而引发ANR。\n\n广播接收器阻塞： 如果在广播接收器中执行耗时操作，可能会导致主线程阻塞，从而引发ANR。\n\n前台服务超时： 前台服务在一定时间内未完成任务可能引发ANR。\n\n系统资源耗尽： 如果应用程序占用了过多的内存、CPU等系统资源，可能导致系统资源不足，从而导致ANR。\n\n\n  为了避免ANR问题，开发人员可以采取以下措施：\n\n在主线程上避免执行耗时操作，将耗时操作放在后台线程中进行。\n使用异步任务、线程池或Handler等机制来处理后台操作。\n使用适当的同步机制，避免发生死锁。\n使用异常处理机制捕获并处理异常，避免应用程序崩溃或阻塞。\n避免在广播接收器中执行耗时操作，尽量保持接收器的执行时间短暂。\n对于前台服务，确保在规定的时间内完成任务。\n对应用程序的资源使用进行优化，避免占用过多的系统资源。\n通过合理的设计和优化，可以有效减少ANR问题的出现，提升应用程序的响应性和用户体验。\n\n\n  \n\n LMK (Low Memory Killer)  LMK（Low Memory Killer）是Android操作系统中的一个重要组件，用于在系统内存不足时终止或杀死一些应用程序进程，以释放内存资源，从而防止系统崩溃或变得不稳定。LMK是Android系统的一种内存管理机制，旨在优化系统的性能和稳定性。\n  LMK的主要原因在于系统内存有限，当多个应用程序同时运行并占用大量内存时，系统可能会出现内存不足的情况。这可能导致系统性能下降、应用程序响应变慢甚至崩溃。为了应对这种情况，LMK会监测系统内存的使用情况，并在内存资源不足时采取措施。\n  LMK的工作原理如下：\n\n内存分级： Android将系统内存划分为不同的级别，每个级别有不同的优先级。这些级别从低到高分为多个”类别”（category）。\n\n内存压力检测： Android的内存管理系统会定期检测系统内存的压力情况。如果系统内存紧张，内存压力会增加。\n\n内存回收： 当内存压力升高时，LMK会开始回收内存资源。它会优先终止优先级较低的应用程序进程，释放它们占用的内存。\n\n杀进程： 如果内存压力继续增加，LMK可能会终止更多的应用程序进程，以释放更多的内存资源。这可能会影响到用户在后台运行的应用程序。\n\n\n  需要注意的是，LMK的设计是为了维护系统的整体稳定性，而不是优先考虑单个应用程序的需求。这意味着，尽管LMK可以确保系统不会因为内存不足而崩溃，但在内存紧张的情况下，一些应用程序可能会被终止以释放资源。\n  开发人员可以通过一些方法来减少应用程序被LMK终止的可能性，例如：\n\n使用适当的内存管理策略，避免内存泄漏和过度使用内存。\n使用合理的后台任务处理机制，避免占用过多的系统资源。\n避免在后台运行过多的进程或服务，以释放更多的内存资源给前台应用程序。\n使用适当的线程和进程管理，避免长时间运行的任务占用过多的内存。\n通过优化应用程序的内存使用和管理，开发人员可以减少LMK的影响，并提供更好的用户体验。\n\n\n  \n\nSystem Kill  “System Kill” 是指 Android 系统在内存紧张的情况下，为了保证系统的稳定性和可用性，选择终止或杀死某些系统进程或服务的行为。这是一种内存管理策略，旨在防止系统耗尽内存资源而导致系统崩溃或不稳定。\n  System Kill 的原因主要是出于系统内存不足的情况。当系统内存紧张，无法满足运行中应用程序和系统进程的内存需求时，系统会采取一些措施来释放内存资源，以防止系统的整体性能下降。System Kill 通常会优先终止一些优先级较低的系统进程，从而为重要的系统进程和前台应用程序腾出更多内存。\n  System Kill 可能影响到一些系统功能和服务，如后台应用程序、系统服务以及一些不常用的进程。然而，系统会优先保留对用户界面、系统核心服务和正在交互的前台应用程序的支持，以确保用户体验和系统的稳定性。\n  在 System Kill 的情况下，一些可能受影响的因素和原因包括：\n\n后台应用程序： 优先终止后台运行的应用程序，释放它们占用的内存资源。\n系统服务： 一些系统服务可能会被终止，导致某些功能受到影响。系统会优先保留核心的系统服务。\n不常用的进程： 一些不常用的进程可能会被终止，以腾出内存。\n进程优先级： 系统会根据进程的优先级来决定终止的顺序。优先级较低的进程可能更容易被终止。  \n\n  需要注意的是，System Kill 是为了确保系统稳定性而采取的一种内存管理策略。在大多数情况下，用户可能不会察觉到 System Kill 的影响，因为系统会尽量保持核心功能和前台应用的正常运行。开发人员应该注意合理管理应用程序的内存使用，以减少被 System Kill 的可能性，并提供更好的用户体验。\n\n  \n\nSIGNALED  在 Android 应用程序中，”Signaled异常退出” 是指应用程序在某些特定情况下收到操作系统信号（signal）而导致异常退出的情况。这些信号可能由操作系统或其他进程触发，通常表示了应用程序遇到了一些严重的问题或错误。这种异常退出可以导致应用程序崩溃、强制关闭或异常终止。\n  在 Android 中，一些常见的导致 Signaled 异常退出的原因包括：\n\nSIGSEGV（Segmentation Violation）： 这是一种段错误信号，表示应用程序试图访问无效的内存地址，通常由于内存访问越界或无效的指针引用导致。\n\nSIGABRT（Abort）： 这是一种中止信号，通常是由于应用程序内部检测到了无法继续运行的错误，比如断言失败或其他逻辑错误。\n\nSIGILL（Illegal Instruction： 这是一种非法指令信号，表示应用程序试图执行不合法的机器指令。\n\nSIGBUS（Bus Error）： 这是一种总线错误信号，表示应用程序试图访问无效的内存地址，类似于 SIGSEGV。\n\nSIGFPE（Floating Point Exception）： 这是一种浮点异常信号，表示应用程序执行了非法的浮点操作，如除以零或溢出。\n\nSIGTERM（Termination）： 这是一种终止信号，通常用于表示应用程序被请求终止，可以由用户、系统或其他进程发起。\n\n其他信号： 还有一些其他的信号，如 SIGHUP、SIGINT、SIGKILL 等，每个信号都有不同的含义和影响。\n\n\n  这些信号可能是由应用程序内部错误、系统问题、库调用失败等多种原因引发的。在 Android 中，一旦应用程序收到了这些信号，通常会触发异常处理机制，有时可能会导致应用程序崩溃或被系统终止。对于某些信号，应用程序可能有机会进行一些清理操作，但有些信号是无法捕获或忽略的，如 SIGKILL。\n  为了减少 Signaled 异常退出的发生，开发人员可以：\n\n编写健壮的代码，避免内存越界、非法指令和浮点异常等问题。\n使用适当的异常处理机制来捕获和处理可能出现的异常情况。\n进行严格的代码测试和质量控制，以发现并修复潜在的问题。\n避免在应用程序中使用无效的指针引用或未经初始化的变量。\n使用合适的错误处理和日志记录，以便能够追踪和调试异常情况。\n\n\n  \n\n EXIT SELF   在 Android 应用程序开发中，”EXIT_SELF” 是指应用程序内部通过编程方式自行选择退出的行为。这意味着应用程序在特定条件下，主动调用代码来触发自身的退出操作，而不是被系统强制退出或由其他外部因素引起的。\n  EXIT_SELF 的原因通常是由于特定的应用逻辑、用户需求或资源管理需要。以下是一些常见的情况和原因，导致 Android 应用程序可能选择进行 EXIT_SELF 操作：\n\n用户主动退出： 应用程序内部提供了退出按钮或选项，让用户主动退出应用，通常通过调用 finish() 方法来实现。\n\n完成任务后退出： 当应用程序完成某个任务、流程或操作后，根据业务需求，可能选择退出以提供一种流程的结束感。\n\n用户状态失效： 在需要用户登录状态的应用中，如果用户登录状态失效（例如，登录过期），应用程序可能会选择退出，以确保用户数据的安全性。\n\n用户权限变更： 如果用户权限发生变化，导致应用程序无法正常运行或提供所需的功能，可能会选择退出。\n\n资源管理： 在资源紧张的情况下，应用程序可能会自行退出以释放资源，例如网络连接不可用、硬件支持不足等。\n\n应用设置： 用户可能在应用设置中设置了特定的退出条件，当这些条件满足时，应用程序可能会执行退出操作。\n\n特殊场景处理： 在某些情况下，应用程序可能会根据特殊的场景需求，如特定时间、地理位置等，选择退出。\n\n测试和调试： 在测试和调试阶段，开发人员可能会在特定情况下触发退出操作以验证应用程序的行为。\n\n\n  在实现 EXIT_SELF 操作时，开发人员应该确保在退出前进行必要的资源释放、数据保存、清理等操作，以确保退出过程的平稳和用户体验。同时，也需要考虑应用退出后的行为，如是否显示退出提示、保存用户数据等。\n  总之，EXIT_SELF 是指应用程序自己选择退出，这在某些场景下可以用于提供更好的用户体验或满足业务需求。\n\n\n以上就是总结的一些Android中的异常退出指标，如有错误欢迎各位大佬指正。\n","categories":["Android"],"tags":["Android","稳定性"]}]